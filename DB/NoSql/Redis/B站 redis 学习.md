[toc]

---

# redis

## 概述

### 是什么

全称 **Remote Dictionary Server**(远程字典服务器) 

- 是完全开源免费的，用 C 语言编写的，遵守 BSD 协议， 
- 是一个高性能的 (key/value) 分布式内存数据库，
- 基于内存运行并支持持久化的 NoSql  数据库，
- 是当前最热门的 NoSql 数据库之也被人们称为数据结构服务器

Redis 与其他 key-value 缓存产品有以下三个特点：

- Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
- Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash等数据结构的存储
- Redis 支持数据的备份，即 master-slave 模式的数据备份


### 能干嘛

内存存储和持久化： redis 支持异步将内存中的数据写到硬盘上。同时不影响継续服务
取最新 N 个数据的操作，如：可以将最新的 10 条评论的 ID 放在 Redds 的 List 集合里面
模拟类似于 Httpsession 这种需要设定过期时间的功能发布、订阅消息系统
定时器、计数器


## 安装

- 下载获得 redis-3.0.4.tar.gz 后将它放入我们的 Linux 目录 /opt
- /opt 日录下，解压命令： tar -zxvf redis-3.0.4.tar.gz 
- 解压完成后出现文件夹： redis-3.0.4
- 进入目录： cd redis-3.0.4
- 在 redis-3.0.4 目录下执行 make 命令。
- 如果 make 完成后继续执行 make install
- 査看默认安装目录： usr/ocal/bin 
- 启动
- 永远的 helloworld 
- 关闭

## 杂项基础知识讲解

- **单进程**

    - 单进程模型来处理客户端的请求，对读写等事件的响应
        是通过对 epoll 的包装来做到的。
        Redis 的实际处理速度完全依靠主进程的执行效率

        Epoll 是 linux内核为处理大批量文件描述符而作了改进的 epoll，是 Linux 下多路复用 IO 接口 select/poLl 的增强版本
        能显著提高程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率
    <!-- <br> -->

- 默认16个数据库，类似数组下表从零开始，初始默认使用零号库

- Select 命令切换数据库

- Dbsize 查看当前数据库的 key 的数量

- Flushdb： 清空当前库

- Flushall： 清空全部库

- 统一密码管理，16个库都是同样密码，要么都 OK 要么一个也连接不上

- Redis 索引都是从零开始

- 为什么默认端口是 6379

# Redis 配置

Redis 常用配置项整理：[link](http：//note.youdao.com/noteshare?id=6b66d529553166a74dd43f65b7cde14b&sub=142D94037AEB4A459AEBA83746B06B63)


## 配置

### 设置 redis 密码（SECURITY）
- redis 默认是没有密码的，但是假如你就是想要设置密码，指令如下：
    ```
    config set requirepass "密码"
    ```
    设置完了只有你如果 `ping` 的话会提示需要验证，这是输入一下指令进行密码输入验证
    ```
    auth 密码
    ```
    然后再 `ping` 的话就可以了
    <br>

- 然后每次访问 reids 都要密码验证，你嫌麻烦不想要密码了，密码如下：
    ```
    config set requirepass ""
    ```

### 限制，极限，最高值（LIMITS）

<br>

#### **Maxmemory-policy**
==面试题：
你是怎么配置 redis 的缓存过期配置的？==

redis 默认使用 neviction 过期策略，假如你想要跟更换过期策略，要在 conf 文件中的 `Maxmemory-policy` 值改成下面的其中一种
```
volatile-lru    ：使用LRU算法移除key，只对设置了过期时间的键
allkeys-lru     ：使用LRU算法移除key 
volatile-random ：在过期集合中移除随机的key，只对设置了过期时间的键
allkeys-random  ：移除随机的key 
volatile-ttl    ：移除那些TTL值最小的key，即那些最近要过期的key 
neviction       ：永不过期，不进行移除。针对写操作，只是返回错误信息
```
上面 5 种，在生产环境下，一定不能用`neviction`永不过期，需要**针对不同的情况选择不同的过期策略**。

#### **Maxmemory-samples**
设置样本数量，LRU 算法和最小 TTL 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小， redis默认会检查这么多个key并选择其中LRU的那个

言下之意，我们有缓存策略的话就需要清洁，清洁的话那怎么知道缓存有多少呢，它就会选取样本进行内部测试，这个就是设置样本数量，默认选取 5 个。

## 启动
注意最好不要用 redis 默认产生的文件，即使要用都要备份一份原始的配置文件
```
redis-server .conf文件路径
```
`config get dir` 可以获取启动的配置文件路径

## 访问操作终端
```
redis-cli -p 6379
```

# Redis 数据类型

## 5 大数据类型

### string

- string是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value 
- string 类型是二进制安全的。意思是 redis的 string可以包含任何数据。比如jpg图片或者序列化的对象。
- string 类型是 Redis 最基本的数据类型，一个 redis 中字符串 value 最多可以是 512M


## key 操作

- `keys *`
- `exists key的名字`，判断某个 key 是否存在
- `move key db`：当前库就没有了，被移除了
- `expire key秒钟`： 为给定的 key 设置过期时间
- `ttl key` 査看还有多少秒过期，-1 表示永不过期，-2 表示已过期
- `type key` 查看你的 key 是什么类型


## string 操作


# -----------------------------------------

# Redis 持久化

## **RDB**

RDB 全称 **Redis DataBase**

### 是什么
**在指定的时间间隔内将内存中的数据集快照写入<u>磁盘</u>**，也就是行话讲的 Snapshot快照，
它恢复时是将快照文件直接读到内存里。

Redis 会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结東了，再用这个临时文件替换上次持久化好的文件。

整个过程中，主进程是不进行任何 IO 操作的，这就确保了<u>极高的性能。</u>

如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。RDB 的缺点是最后一次持久化后的数据可能丢失。


## **AOF**

AOF 全称 **Append Only File**

### AOF 是什么

以日志的形式来记录每个写操作，将 Redis 执行过的所有写指令记录下来(读操作不记录)，
只许追加文件但不可以改写文件，redis 启动之初会读取该文件重新构建数据，
换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作


### rewrite

#### 是什么

AOF 采用文件追加方式，文件会越来越大为避免出现此种情况，新増了重写机制，当 AOF 文件的大小超过所设定的阙值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。
可以使用命令 `bgrewriteaof`

#### 重写原理
AOF 文件持续增长而过大时，会 fork 出一条新进程来将文件重写(也是先写临时文件最后再 rename)，
遍历新进程的内存中数据，每条记录有一条的 set 语句。

重写 aof 文件的操作，并没有读取旧的 aof 文件而是将整个内存中的数据库内容用命令的方式重写了一个新的 aof文件，这点和快照有点类似

#### 触发机制
Redis 会记录上次重写时的 AOF 大小，
默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于64M 时触发

### 优缺点
- 优点

每秒同步： appendfsync always 同步持久化每次发生数据变更会被立即记录到磁盘性能较差但数据完整性较高

每修改同步： appendfsync everysec 异步操作，每秒记录如果一秒内宕机，有数据丢失

不同步： appendfsync no 从不同步

- 缺点

相同数据集的数据而言 aof 文件要远大于 rdb 文件，恢复速度慢于 rdb 
Aof 运行效率要慢于 rdb，每秒同步策略效率较好，不同步效率和 rdb 相同


### 小总结

- AOF 文件时一个只进行追加的日志文件
- Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写 
- AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存，因此 AOF 文件的内容非常容易被人读懂，对文件进行分析也很轻松

- 对于相同的数据集来说，AOF 文件的体积通常要大于RDB文件的体积
- 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB



## RDB 与 AOF 的选择

RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储 
AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据， AOF 命令以 redis 协议追加保存每次写的操作到文件末尾 
Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大
只做缓存：如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化方式


### 同时开启两种持久化方式
在这种情况下，当 redis 重启的时候会优先载入 AOF 文件来恢复原始的数据
因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。

RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。
那要不要只使用 AOF 呢？作者建议不要。
因为 RDB 更适合用于备份数据库 ( AOF 在不断变化不好备份)，快速重启，
而且不会有 AOF 可能潜在的 bug，留着作为一个万一的手段。

### 性能建议

性能建议因为 RDB 文件只用作后备用途，建议只在 Slave 上持久化 RDB 文件，而且只要15分钟备份一次就够了，只保留 save 9001这条规

- 如果 Enabel AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只 load 自己的 AOF 文件就可以了。
**代价**
    - 1、是带来了持续的 IO，
    - 2、是 AOF rewrite的最后将 rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。
    只要硬盘许可，应该尽量减少 AOF rewrite的频率，
    AOF重写的基础大小默认值 64M 太小了，可以设到 5G 以上。默认超过原大小 100% 大小时重写可以改到适当的数值

- 如果不 Enable AOF，仅靠 **Master-Slave Replication** 实现高可用性也可以。
能省掉一大笔IO也减少了 rewrite 时带来的系统波动。
新浪博就选用了这种架构。
**代价**
    - 如果 Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/ Slave 中的 RDB 文件，载入较新的那个。


---

# Redis 事务

## 常用指令

TODO

## 使用 case

### watch 监控


悲观锁/乐观锁/CAS(Check And Set)
初始化信用卡可用余额和欠额
无加塞篡改，先监控再开启 multi 保证两笔金额变动在同一个事务内
有加塞算改
unwatch
一且执行了 exec 之前加的监控锁都会被取消掉了
小结

#### 悲观锁
悲观锁( Pessimistic Lock)，顾名思义，就是很悲观。每次去拿数据的时候都认定别人会修改。
所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。

传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁， 写锁等，都是在做操作之前先上锁

悲观锁可以保证强一致性，但是相应的，并发性性能大大减弱。

每次操作都把整张表先锁住，防止别人同一时间也进来该表。

缺点：
并发性能差，即假如别人想跟同一张表但不是同一行数据，你把整张表都锁了，别人只能等你改完了再改。

#### 乐观锁
乐观锁 (Optimistic Lock)
顾名思义，就是很乐观，每次去拿数据的时候都认定别人不会修改。
所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据（使用版本号等机制）。

乐观锁适用于多读的应用类型，这样可以提高吞吐量

乐观锁策略：
提交版本必须大于记录当前版本才能执行更新
(原理同 git 的版本号控制)


#### 小结

Watch 指令，类似乐观锁。
事务提交时，如果 Key 的值己被别的客户端改变比如某个 list 已被别的客户端 push/pop 过了，整个事务队列都不会被执行

通过 WATCH 命令在事务执行之前监控了多个 Keys，倘若在 WATCH 之后有任何 Key 的值发生了变化，
EXEC命令执行的事务都将被放弃，同时返回 Nullmulti-bulk 应答以通知调用者事务执行失败


## 事务 3 阶段

开启：以 MULTI 开始一个事务
入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面
执行：由 EXEC 命令触发事务

## 事务 3 特性

单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送米的命令请求所打断
没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行也就不存在"事务内的查询要看到事务里的更新，在事务外查询不能看到"这个让人万分头痛的问题
不保证原子性：redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚


# Redis 发布与订阅

进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(Sub)接收消息。
订阅/发布消息图

## 例子

先订阅后发布后才能收到消息，
1、可以一次性订阅多个，`SUBSCRIBE c1 c2 c3`
2、消息发布，`PUBLISH c2 hello-redis`

3、订阅多个，通配符*，`PSUBSCRIBE new*`
4、收取消息，`PUBLISH new1 redis2015`


# Redis 的复制 (Master/Slave
)

行话：也就是我们所说的主从复制。
主机数据更新后根据配置和策略，自动同步到备机的 master/slaver 机制，
Master 以写为主，Slave 以读为主 

1. 配从(库)不配主(库) 
2. 从库配置：slaveof 主库IP主库端口
    - 每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件 
    - Info replication

3. 修改配置文件细节操作
    1. 拷贝多个 redis.conf 文件
    2. 开启 daemonize yes 
    3. Pid文件名字指定端口
    4. Log 文件名字
    5. Dump.rdb 名字

4. 常用 3 招
    - 一主二仆
    - 薪火相传
    - 反客为主

## 常用 3 种模式

### 一主二仆

### 薪火相传

上一个 Slave 可以是下一个 slave 的 Master，Slave 同样可以接收其他 slaves 的连接和同步请求，那么该 slave 作为了链条中下一个的 master，可以有效减轻 master 的写压力
中途变更转向：会清除之前的数据，重新建立拷贝最新的
Slaveof 新主库 IP 新主库端口

### 反客为主

从机上位成为主机


## 复制原理

Slave 启动成功连接到 master 后会发送一个 sync 命令
Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave，以完成一次完全同步

- 全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。（重新连接 master 时，自动执行全量复制）
- 增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步


## 哨兵

是什么
怎么玩(使用步骤) 
一组 sentinel 能同时监控多个 Master


反客为主的自动版。能够后台监控主机是否故障。
如果故了根据投票数自动将从库转換为主库

1. 调整结构，6379带着80、81 
2. 自定义的 /myredis 目录下新建 sentinel.conf 文件，名字绝不能错
3. 配置哨兵，填写内容
    - `sentinel monitor 被监控数据库名字(自己起名字)127.0.0.16379 1` 
    上面最后一个数字 1，表示主机挂掉后 slave 投票看让谁接替成为主机，得票数多的从机成为主机
4. 启动哨兵
    - `Redis-sentinel /sentinel.conf哨兵配置文件路径`
5. 正常主从演示
6. 原有的 master 挂了
7. 投票新选重新主从继续开工，info replication 查看
8. 问题：如果之前的 master 重启回来，会不会双 master 冲突？

## 复制缺点

复制延时由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟。
当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重

