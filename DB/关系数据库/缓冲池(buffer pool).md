# 目录

[toc]

---

[转载！出处](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ%3D%3D&chksm=bd2d098e8a5a809834aaa07da0d7546555385543fb6d687a7cf94d183ab061cd301a76547411&idx=1&mid=2651962450&scene=21&sn=ce17c4da8d20ce275f75d0f2ef5e40c9#wechat_redirect) 


# 缓冲池 (buffer pool)，这次彻底懂了！！！

应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在缓存(cache)里，避免每次都去访问数据库。
操作系统，会有 **缓冲池 (buffer pool) 机制**，避免每次访问磁盘，以加速数据的访问。

MySQL 作为一个存储系统，同样具有缓冲池 (buffer pool) 机制，以避免每次查询数据都进行磁盘 IO 。

今天，和大家聊一聊 InnoDB 的缓冲池。

## InnoDB 的缓冲池缓存什么？有什么用？

缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，
避免每次访问都进行磁盘 IO ，起到加速访问的作用。



**速度快，那为啥不把所有数据都放到缓冲池里？**

凡事都具备两面性，抛开数据易失性不说，**<u>访问快速的反面是存储容量小</u>**：

（ 1 ）缓存访问快，但容量小，数据库存储了 200G 数据，缓存容量可能只有 64G ；
（ 2 ）内存访问快，但容量小，买一台笔记本磁盘有 2T ，内存可能只有 16G ；

因此，只能把 **==“最热”==** 的数据放到“最近”的地方，以“最大限度”的降低磁盘访问。
<br>



## 如何管理与淘汰缓冲池，使得性能最大化呢？

在介绍具体细节之前，先介绍下 **“预读”** 的概念。

### 什么是预读？

磁盘读写，并不是按需读取，
而是 <u>**==按页读取==**，一次至少读一页数据（一般是 4K ）</u>，
**<u>如果未来要读取的数据就在页中</u>**，就能够省去后续的磁盘 IO ，提高效率。
<br>


### 预读为什么有效？

数据访问，通常都遵循 **<u>“集中读写”</u>** 的原则，
==使用一些数据，大概率会使用附近的数据== ，这就是所谓的 “局部性原理”，
它表明 <u>**提前加载是有效的**</u>，确实能够减少磁盘 IO 。
<br>



### 按页 (4K) 读取，和 InnoDB 的缓冲池设计有啥关系？

（ 1 ）磁盘访问 <u>按页读取能够提高性能</u> ，所以 <u>缓冲池一般也是 **==按页缓存==** 数据</u>；
（ 2 ）预读机制启示了我们，能 <u>把一些 **“可能要访问”** 的 ==**页**== 提前加入缓冲池，避免未来的磁盘 IO 操作</u>；
<br>



## InnoDB 是以什么算法，来管理这些缓冲页呢？

最容易想到的，就是 **==LRU==** (Least recently used) 。

（memcache ， OS 都会用 LRU 来进行页置换管理，但 MySQL 的玩法并不一样）



### 传统的 LRU 是如何进行缓冲页管理？

最常见的玩法是，<u>把 **入缓冲池的页** 放到 LRU 的头部，作为最近访问的元素</u>，从而最晚被淘汰。
这里又分两种情况：
（ 1 ）**页已经在缓冲池里**，那就 <u>只做 “移至” LRU 头部的动作</u>，而没有页被淘汰；
（ 2 ）**页不在缓冲池里**， <u>除了做 “放入” LRU 头部的动作，还要做“淘汰” LRU 尾部页的动作</u>；





<br>
<br><br><br><br><br><br><br><br><br><br><br>

---

<u></u>

**<u></u>**
**====**
