[toc]

---


[source](https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483934&idx=1&sn=41c46eceb2add54b7cde9eeb01412a90&chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&scene=21#wechat_redirect)

# 1、什么是类的加载

类的加载指的是
1. 将类的 **`.class`** 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，
2. 然后在 ==**堆区**== 创建一个 **`java.lang.Class` 对象**，用来封装类在方法区内的数据结构。

<u>类的加载的最终产品是 **位于堆区中的 Class 对象**</u>， 
Class 对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。

<img style="width:600px" src="..\img\JVM\class.png"></img>




类加载器并不需要等到某个类被“首次主动使用”时再加载它，
**JVM 规范允许类加载器在预料某个类将要被使用时就 ==预先加载== 它，
==如果在预先加载的过程中遇到了 .class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（ `LinkageError` 错误）==**
如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误


## 加载 `.class` 文件的方式

- 从本地系统中直接加载

- 通过网络下载 .class 文件

- 从 zip, jar 等归档文件中加载 .class 文件

- 从专有数据库中提取 .class 文件

- 将 Java 源文件动态编译为 .class 文件


# 2、类的生命周期

<img style="width:750px" src="..\img\JVM\类的生命周期1.png"></img>

其中类加载的过程包括了 **加载、验证、准备、解析、初始化** 五个阶段。
在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，
而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。
另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，
因为 **这些阶段通常都是互相交叉地混合进行的**，通常在一个阶段执行（还没结束）的过程中调用或激活另一个阶段。


## 加载

**查找并加载类的二进制数据**。加载是类加载过程的第一个阶段。

在加载阶段，虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取其定义的 **二进制字节流**。
2. 将这个字节流所代表的静态存储结构转化为 **方法区** 的运行时数据结构。
3. 在 Java **堆中** 生成一个代表这个类的 `java.lang.Class` 对象，作为对方法区中这些数据的访问入口。

相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，
因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，
而且在 Java 堆中也创建一个 **`java.lang.Class`** 类的对象，这样便可以通过该对象访问方法区中的这些数据。


## 连接 link （验证）

**验证：确保被加载的类的正确性**

验证是连接阶段的第一步，
<u>这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，
并且不会危害虚拟机自身的安全</u>。

验证阶段大致会完成4个阶段的检验动作：

1、**文件格式验证**：验证字节流是否符合 Class 文件格式的规范；
例如：是否以 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。

2、**元数据验证**：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），
以保证其描述的信息符合 Java 语言规范的要求；
例如：这个类是否有父类，除了 java.lang.Object之外。

3、**字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

4、**符号引用验证**：确保解析动作能正确执行。

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，
如果所引用的类经过反复验证，那么可以考虑采用 `-Xverifynone` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。



## 准备

**准备：为类的 静态变量分配内存，并将其初始化为默认值**

准备阶段是正式 **为类变量分配内存** 并 **设置类变量初始值的阶段**，这些内存都将在方法区中分配。

对于该阶段有以下几点需要注意：
<b style="color:rgb(66, 80, 190);">①、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，</b>
实例变量会在对象实例化时随着对象一块分配在Java堆中。

<b style="color:rgb(66, 80, 190);">②、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），</b>
而不是被在Java代码中被显式地赋予的值。

假设一个类变量的定义为： 
```java
public static int value = 3；
```
那么 **变量 value 在准备阶段过后的初始值为 0** ，而不是 3 ，
因为这时候尚未开始执行任何 Java 方法，
而把 value 赋值为 3 的 public static 指令是在程序编译后，存放于 **类构造器 `<clinit>()`** 方法之中的，
所以把 value 赋值为 3 的动作将在初始化阶段才会执行。

这里还需要注意如下几点：

- 对基本数据类型来说，
对于类变量（ static ）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，
<u>而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</u>

- 对于同时被 `static` 和 `final` 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；
而只被 `final` 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，
总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
- 对于引用数据类型 `reference` 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即 null 。
- 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

<b style="color:rgb(66, 80, 190);">③、如果类字段的字段属性表中存在 `ConstantValue` 属性，即同时被 `final` 和 `static` 修饰，那么在准备阶段变量 value 就会被初始化为 `ConstValue` 属性所指定的值。</b>


假设上面的类变量 value 被定义为： 
```java
public static final int value=3 ；
```

编译时 Javac 将会为 value 生成 `ConstantValue` 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3 。
我们可以理解为 `static final` 常量在编译期就将其结果放入了调用它的类的常量池中








<br>
<br><br><br><br><br><br>


<u></u>

<img style="width:500px" src=""></img>


<b style="color:rgb(66, 80, 190);"></b>



