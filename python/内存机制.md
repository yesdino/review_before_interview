[toc]

---

[参考](https://www.cnblogs.com/geaozhang/p/7111961.html)

# 一、变量与对象

关系图如下：
![image](https://images2015.cnblogs.com/blog/1113510/201707/1113510-20170703162719722-1993553654.png)


## 1、变量。通过变量指针引用对象

**==变量指针==** ：指向具体对象的内存空间，取对象的值。

## 2、对象。类型已知
每个对象都包含一个 **头部信息**
（头部信息：类型标识符和引用计数器）

注意：
**==变量名没有类型，对象才有类型==**（因为变量引用对象，所以类型随对象）。
变量引用什么类型的对象，变量就是什么类型的。
```py

var1 = object
var2 = var1  # 赋值: 赋值变量的引用 即指向的内存地址

# var1 ---> object
# var2 ---> object 指向同一个对象 不是 var2 -> var1 -> object

# id()是python的内置函数，用于返回对象的内存地址。
print(id(var1))
# 139697863383968

print(id(var2))
# 139697863383968
```

![image1](https://images2015.cnblogs.com/blog/1113510/201707/1113510-20170703163116440-978220497.png)



```py
a = 123
b = a
print(id(a))    # 23242832
print(id(b))    # 23242832

a = 456         # 此时 a 已经指向别的地址了 b 没有改变指向
print(id(a))    # 33166408
print(id(b))    # 23242832 
# 注意 b 的指向不是 b --> a --> object
```

## 3、引用所指判断

通过 is 进行引用所指判断，
is 是用来判断两个引用 **所指的对象是否相同**。

整数
```py
a = 1
b = 1
print(a is b)   # True
```

短字符串
```py
c = "good"
d = "good"
print(c is d)   # True
```

长字符串
```py
e = "very good"
f = "very good"
print(e is f)   # False
```

列表
```py
g = []
h = []
print(g is h)   # False
```

由运行结果可知：
- 1、Python 缓存了 **整数** 和 **短字符串** ，因此每个对象在内存中只存有一份，引用所指对象就是相同的，即使使用赋值语句，也只是创造新的引用，而不是对象本身；
- 2、Python 没有缓存 **长字符串**、 **列表** 及 **其他对象**，可以由多个相同的对象，可以使用赋值语句创建出新的对象。

 

# 二、引用计数

在Python中，每个对象都有指向该对象的引用总数。
即，有多少个变量指向改对象

查看对象的引用计数：
## sys.getrefcount()

## 1、普通引用
```py
import sys

a = [1,2,3]

# 参数a创建临时变量 多一条引用
print(getrefcount(a))   # 变量a指向的对象有多少条引用
# 2

b = a
print(getrefcount(a))   # 变量a指向的对象有多少条引用
# 3
print(getrefcount(b))   # 变量b指向的对象有多少条引用
# 3
```
注意：
当使用某个引用作为参数，传递给 `getrefcount()` 时，参数实际上创建了一个临时的引用。因此，`getrefcount()` 所得到的结果，会比期望的多1。

## 2、容器对象
Python的一个容器对象(比如：表、词典等)，
可以包含多个对象。

```py
a = [1,2,3,4,5]
b = a       # 注意a把引用赋值给b的同时 也把修改对象的权利给了b

print(a is b)
# True

a[0] = 6   
print(a)
# [6, 2, 3, 4, 5]

print(a is b)
# True

print(b)
# [6, 2, 3, 4, 5]
```

由上可见，实际上，
**==容器对象中包含的并不是元素对象本身，是指向各个元素对象的引用。==**
**==第二行，a把引用赋值给b的同时，也把修改对象的权利给了b==**

## 3、引用计数增加

- 1、对象被创建
```py
# 123 这个对象本身有多少条引用
print(getrefcount(123))
# 6
n = 123
print(getrefcount(123))
# 7
```
- 2、另外的别人被创建
```py
m = n
print(getrefcount(123))
# 8
```
- 3、作为容器对象的一个元素
```py
# 123 只是作为列表的其中一个元素都会多一条引用
a = [1, 12, 123]
print(getrefcount(123))
# 9
```
- 4、被作为参数传递给函数
==参数会自动创建一个临时变量==
```py
foo(123)
print(getrefcount(123))
# 10
```

## 4、引用计数减少

对象的别名： 指向对象的变量
-　1、指向对象的变量被显式的销毁

```py
del m
print(getrefcount(123))
# 8
```
-　2、指向对象的变量被赋值给其他对象

```py
n = 456
print(getrefcount(123))
# 7
```
-　3、对象从一个窗口对象中移除，或，窗口对象本身被销毁
```py
a.remove(123)
print(a)
# [1, 12]
print(getrefcount(123))
# 6
```
-　4、一个本地引用离开了它的作用域，比如上面的foo(x)函数结束时，x指向的对象引用减1。

 

# 三、垃圾回收 garbage collection

当Python中的对象越来越多，占据越来越大的内存，启动垃圾回收(garbage collection)，将没用的对象清除。

## 原理
当Python的某个对象的 **引用计数降为0** 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾。

比如某个新建对象，被分配给某个引用，对象的引用计数变为1。
如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。
```py
a = [321,123]
del a
```
`del a`后，已经没有任何引用指向之前建立的[321,123]，该表引用计数变为0，用户不可能通过任何方式接触或者动用这个对象，
当垃圾回收启动时，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。

**注意**
- 1、垃圾回收时，Python不能进行其它的任务，频繁的垃圾回收将大大降低Python的工作效率；

- 2、Python只会在 **特定条件下**，自动启动垃圾回收（垃圾对象少就没必要回收）

- 3、当Python运行时，会记录其中 **分配对象**(`object allocation`)和 **取消分配对象**(`object deallocation`)的次数。
当两者的差值高于某个阈值时，垃圾回收才会启动。
可使用 **gc.get_threshold( )** 查看阈值

## 阈值
启动垃圾回收的临界值
### 按照系统设定启动
```py
import gc

print(gc.get_threshold())　　# gc 模块中查看阈值的方法
# (700, 10, 10)
```
```py
700 : 垃圾回收启动的阈值；
10  : 每 10 次 0 代垃圾回收，会配合 1 次 1 代的垃圾回收；
10  : 每 10 次 1 代的垃圾回收，才会有 1 次的 2 代垃圾回收；
```
### 手动启动
当然也是可以使用 **gc.collect( )** **手动启动** 垃圾回收：　
```py
gc.collect()    # 手动启动垃圾回收
# 2
```

## 分代回收

- Python将所有的对象分为 0，1，2 三代；
- 所有的新建对象都是0代对象；
- 当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。

 

# 四、内存池机制

Python中有分为 **大内存** 和 **小内存** ：
（256K为界限分大小内存）

1、大内存使用 **malloc** 进行分配
2、小内存使用 **内存池** 进行分配

## Python的内存池(金字塔)
- **第 3 层：最上层。**
用户对 Python 对象的直接操作<br><br>

- **第 1 层和第 2 层：内存池。**
由有 Python 的接口函数 **PyMem Malloc** 实现。
若请求分配的内存在 1~256 字节之间就使用内存池管理系统进行分配，
调用 **malloc( )** 函数分配内存，
但是每次只会分配一块大小为 256K 的大块内存，
不会调用 **free( )** 函数释放内存，
将该内存块留在内存池中以便下次使用。 <br><br>

- **第 0 层：大内存。**
若请求分配的内存大于 256K ， 
**malloc( )** 函数分配内存， **free( )** 函数释放内存。 <br><br>

- **第 -1 ， -2 层**：操作系统进行操作

