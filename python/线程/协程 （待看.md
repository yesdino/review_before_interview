[出处](http://www.imooc.com/article/263959)

<div><div class="cl-preview-section"><p>说明：本文翻译自<a href="https://docs.python.org/3/library/asyncio-task.html#running-an-asyncio-program">Coroutines and Tasks</a>，主要介绍asyncio中用于处理协程和任务的方法和接口。在翻译过程中，译者在官方文档的基础上增加了部分样例代码和示意图表，以帮助读者对文档的理解。本文所述内容主要针对Python3.7，对3.7之前的版本有可能不适用，敬请注意。原创内容，转载请注明出处。<br>
译者：马鸣谦</p>
</div><div class="cl-preview-section"><h2 id="协程">协程</h2>
</div><div class="cl-preview-section"><p>协程（coroutines）是通过<code>async/await</code>定义函数或方法，是使用asyncio进行异步编程的首选途径。如下，是一个协程的例子：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
  <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span>

</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><!--more-->
</div><div class="cl-preview-section"><p>上例中的 <code>main</code> 方法就是我们定义的<code>协程</code> 。<br>
我们在交互环境(Python3.7)下执行以上代码，看看效果：</p>
</div><div class="cl-preview-section"><pre class="  language-bash"><code class="prism  language-bash"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token function">import</span> asyncio

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> async def main<span class="token punctuation">(</span><span class="token punctuation">)</span>:
<span class="token punctuation">..</span>.     print<span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
<span class="token punctuation">..</span>.     await asyncio.sleep<span class="token punctuation">(</span>1<span class="token punctuation">)</span>
<span class="token punctuation">..</span>.     print<span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> asyncio.run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">))</span>
hello
world
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>需要注意的是：如果像执行普通代码一样直接调用<code>main()</code>，只会返回一个<code>coroutine</code>对象，<code>main()</code>方法内的代码不会执行：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">#直接执行`main()`返回的是一个`coroutine对象`。</span>
<span class="token operator">&lt;</span>coroutine <span class="token builtin">object</span> main at <span class="token number">0x0000000002C97848</span><span class="token operator">&gt;</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>实际上，asyncio提供了三种执行<code>协程</code>的机制：</p>
</div><div class="cl-preview-section"><ol>
<li><strong>使用<code>asyncio.run()</code>执行协程。一般用于执行最顶层的入口函数，如<code>main()</code>。</strong></li>
<li><strong><code>await</code>一个<code>协程</code>。一般用于在一个<code>协程</code>中调用<code>另一协程</code>。</strong> 如下是一个示例：</li>
</ol>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> time
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">say_after</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span>what<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>what<span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"started at {time.strftime('%X')}"</span><span class="token punctuation">)</span>
        <span class="token keyword">await</span> say_after<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span>
        <span class="token keyword">await</span> say_after<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"world"</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"finished at {time.strftime('%X')}"</span><span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
started at <span class="token number">16</span><span class="token punctuation">:</span><span class="token number">47</span><span class="token punctuation">:</span><span class="token number">10</span>
hello
world
finished at <span class="token number">16</span><span class="token punctuation">:</span><span class="token number">47</span><span class="token punctuation">:</span><span class="token number">13</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>执行耗时 <strong>3秒</strong><br>
3. <strong>用<code>asyncio.create_task()</code>方法将<code>Coroutine（协程）</code>封装为<code>Task（任务）</code>。一般用于实现异步并发操作。</strong> 需要注意的是，只有在当前线程存在事件循环的时候才能创建任务（Task）。</p>
</div><div class="cl-preview-section"><p>我们修改以上的例程，<strong>并发执行</strong> 两个<code>say_after</code>协程。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    task1 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>say_after<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    task2 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>say_after<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"started at {time.strftime('%X')}"</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> task1
    <span class="token keyword">await</span> task2
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"finished at {time.strftime('%X')}"</span><span class="token punctuation">)</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>执行<code>asyncio.run(main())</code>,结果如下：</p>
</div><div class="cl-preview-section"><pre><code>started at 17:01:34
hello
world
finished at 17:01:36
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p><strong>耗时2秒</strong></p>
</div><div class="cl-preview-section"><h2 id="“可等待”对象（awaitables）">“可等待”对象（Awaitables）</h2>
</div><div class="cl-preview-section"><p>如果一个对象能够被用在<code>await</code>表达式中，那么我们称这个对象是<code>可等待对象（awaitable object）</code>。很多<code>asyncio API</code>都被设计成了<code>可等待的</code>。<br>
主要有三类<strong>可等待</strong>对象：</p>
</div><div class="cl-preview-section"><ul>
<li>协程<code>coroutine</code></li>
<li>任务<code>Task</code></li>
<li>未来对象<code>Future</code>。</li>
</ul>
</div><div class="cl-preview-section"><h3 id="coroutine（协程）">Coroutine（协程）</h3>
</div><div class="cl-preview-section"><p>Python的<code>协程</code>是<code>可等待的（awaitable）</code>，因此能够被其他<code>协程</code>用在<code>await</code>表达式中。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"something"</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 如果直接调用 "nested()"，什么都不会发生.</span>
    <span class="token comment"># 直接调用的时候只是创建了一个 协程对象 ，但这个对象没有被 await,</span>
    <span class="token comment"># 所以它并不会执行.</span>
    nested<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 那么我们 await 这个协程，看看会是什么结果:</span>
    <span class="token keyword">await</span> nested<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 将会打印 "something".</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p><strong>重要</strong>：在这篇文章中，术语<code>coroutine</code>或<code>协程</code>指代两个关系紧密的概念：</p>
</div><div class="cl-preview-section"><ul>
<li><code>协程函数（coroutine function）</code>:由<code>async def</code>定义的函数；</li>
<li><code>协程对象（coroutine object）</code>：调用 <code>协程函数</code>返回的对象。</li>
</ul>
</div><div class="cl-preview-section"><p>asyncio也支持传统的基于生成器的协程。</p>
</div><div class="cl-preview-section"><h3 id="task（任务）">Task（任务）</h3>
</div><div class="cl-preview-section"><p><code>Task</code>用来 <strong>并发的</strong> 调度协程。<br>
当一个<code>协程</code>通过类似 <code>asyncio.create_task()</code> 的函数被封装进一个 <code>Task</code>时，这个<code>协程</code> 会很快被自动调度执行：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">nested</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token number">42</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Schedule nested() to run soon concurrently</span>
    <span class="token comment"># with "main()".</span>
    task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>nested<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># "task" can now be used to cancel "nested()", or</span>
    <span class="token comment"># can simply be awaited to wait until it is complete:</span>
    <span class="token keyword">await</span> task

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><h3 id="future（未来对象）">Future（未来对象）</h3>
</div><div class="cl-preview-section"><p><code>Future</code> 是一种特殊的 <strong>底层</strong> 可等待对象，代表一个异步操作的<strong>最终结果</strong>。<br>
当一个<code>Future</code>对象被<code>await</code>的时候，表示当前的协程会持续等待，直到 <code>Future</code>对象所指向的异步操作执行完毕。<br>
在asyncio中，<code>Future</code>对象能使<strong>基于回调</strong>的代码被用于<code>asyn/await</code>表达式中。<br>
<strong>一般情况下</strong>，在应用层编程中，<strong>没有必要</strong> 创建<code>Future</code>对象。<br>
有时候，有些<code>Future</code>对象会被一些库和asyncio API暴露出来，我们可以<code>await</code>它们：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">await</span> function_that_returns_a_future_object<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># this is also valid:</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>
        function_that_returns_a_future_object<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        some_python_coroutine<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>底层函数返回<code>Future</code>对象的一个例子是：<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor">loop.run_in_executor</a></p>
</div><div class="cl-preview-section"><h2 id="执行asyncio程序">执行asyncio程序</h2>
</div><div class="cl-preview-section"><pre><code>asyncio.run(coro, * , debug=False)
</code></pre>
</div><div class="cl-preview-section"><p>这个函数运行<code>coro</code>参数指定的 <code>协程</code>，负责 <strong>管理asyncio事件循环</strong> ， <strong>终止异步生成器</strong>。<br>
在同一个线程中，当已经有asyncio事件循环在执行时，不能调用此函数。<br>
如果<code>debug=True</code>，事件循环将运行在 <strong>调试模式</strong>。<br>
此函数总是创建一个新的事件循环，并在最后关闭它。建议将它用作asyncio程序的主入口，并且只调用一次。<br>
<em>Python3.7新增</em><br>
<strong>重要</strong>：这个函数是在Python3.7被临时添加到asyncio中的。</p>
</div><div class="cl-preview-section"><h2 id="创建task">创建Task</h2>
</div><div class="cl-preview-section"><pre><code>asyncio.create_task(coro)
</code></pre>
</div><div class="cl-preview-section"><p>将<code>coro</code>参数指定的<code>协程（coroutine）</code>封装到一个<code>Task</code>中，并调度执行。返回值是一个<code>Task</code>对象。<br>
任务在由<a href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_running_loop"><code>get_running_loop()</code></a>返回的事件循环（loop）中执行。如果当前线程中没有正在运行的事件循环，将会引发<a href="https://docs.python.org/3/library/exceptions.html#RuntimeError"><code>RuntimeError</code></a>异常:</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">coro_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"do somthing"</span><span class="token punctuation">)</span>

task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>coro_1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>因为当前线程中没有正运行的事件循环，所以引发异常：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"C:\Program Files\Python37\lib\site-packages\IPython\core\interactiveshell.py"</span><span class="token punctuation">,</span> line <span class="token number">3265</span><span class="token punctuation">,</span> <span class="token keyword">in</span> run_code
    <span class="token keyword">exec</span><span class="token punctuation">(</span>code_obj<span class="token punctuation">,</span> self<span class="token punctuation">.</span>user_global_ns<span class="token punctuation">,</span> self<span class="token punctuation">.</span>user_ns<span class="token punctuation">)</span>
  File <span class="token string">"&lt;ipython-input-4-456c15a4ed16&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
    task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>coro_1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  File <span class="token string">"C:\Program Files\Python37\lib\asyncio\tasks.py"</span><span class="token punctuation">,</span> line <span class="token number">324</span><span class="token punctuation">,</span> <span class="token keyword">in</span> create_task
    loop <span class="token operator">=</span> events<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
RuntimeError<span class="token punctuation">:</span> no running event loop

</code></pre>
</div><div class="cl-preview-section"><p>对以上代码稍作修改，创建<code>main()</code>方法，在其中创建<code>Task</code>对象，然后在主程序中利用<code>asyncio.run()</code>创建<code>事件循环</code>：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">coro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"something is running"</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>coro<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>执行结果如下：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&lt;</span>_WindowsSelectorEventLoop running<span class="token operator">=</span><span class="token boolean">True</span> closed<span class="token operator">=</span><span class="token boolean">False</span> debug<span class="token operator">=</span><span class="token boolean">False</span><span class="token operator">&gt;</span>
something <span class="token keyword">is</span> running
</code></pre>
</div><div class="cl-preview-section"><p>此函数已经被引入到Python3.7。在Python早期版本中，可以使用底层函数<code>asyncio.ensure_future()</code>代替。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">coro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token comment"># In Python 3.7+</span>
task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>coro<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token comment"># This works in all Python versions but is less readable</span>
task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>coro<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p><em>Python3.7新增</em></p>
</div><div class="cl-preview-section"><h2 id="sleeping">Sleeping</h2>
<pre><code>coroutine asyncio.sleep(delay,result=None,* ,loop=None)
</code></pre>
</div><div class="cl-preview-section"><p>阻塞<code>delay</code>秒，例如<code>delay=3</code>，则阻塞3秒。<br>
如果指定了<code>result</code>参数的<code>值</code>，则在协程结束时，将该<code>值</code>返回给调用者。<br>
<code>sleep()</code>通常只暂停当前<code>task</code>，并不影响其他<code>task</code>的执行。<br>
不建议使用<code>loop</code>参数，因为Python计划在<code>3.10</code>版本中移除它。<br>
以下是一个协程的例子，功能是<code>在5秒钟内，每秒显示一次当前的日期</code>：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> datetime

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">display_date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    end_time <span class="token operator">=</span> loop<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5.0</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> end_time<span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>display_date<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>执行结果大致如下：</p>
</div><div class="cl-preview-section"><pre><code>2018-11-20 11:27:15.961830
2018-11-20 11:27:16.961887
2018-11-20 11:27:17.961944
2018-11-20 11:27:18.962001
2018-11-20 11:27:19.962059
2018-11-20 11:27:20.962116
</code></pre>
</div><div class="cl-preview-section"><h2 id="并发执行tasks">并发执行Tasks</h2>
<pre><code>awaitable asyncio.gather(* aws, loop=None, return_exceptions=False)
</code></pre>
</div><div class="cl-preview-section"><p>并发执行<code>aws</code>参数指定的 <code>可等待（awaitable）对象</code>序列。<br>
如果 <code>aws</code> 序列中的某个 <code>awaitable 对象</code> 是一个 <code>协程</code>,则自动将这个 <code>协程</code> 封装为 <code>Task</code>对象进行处理。例如：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span>
    f <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> number <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Task {name}: Compute factorial({i})..."</span><span class="token punctuation">)</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        f <span class="token operator">*=</span> i
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Task {name}: factorial({number}) = {f}"</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Schedule three calls *concurrently*:</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>
        factorial<span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        factorial<span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        factorial<span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># Expected output:</span>
<span class="token comment">#</span>
<span class="token comment">#     Task A: Compute factorial(2)...</span>
<span class="token comment">#     Task B: Compute factorial(2)...</span>
<span class="token comment">#     Task C: Compute factorial(2)...</span>
<span class="token comment">#     Task A: factorial(2) = 2</span>
<span class="token comment">#     Task B: Compute factorial(3)...</span>
<span class="token comment">#     Task C: Compute factorial(3)...</span>
<span class="token comment">#     Task B: factorial(3) = 6</span>
<span class="token comment">#     Task C: Compute factorial(4)...</span>
<span class="token comment">#     Task C: factorial(4) = 24</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>如果所有的<code>awaitable</code>对象都执行完毕，则返回 <strong>awaitable对象执行结果的聚合列表</strong>。返回值的顺序于<code>aws</code>参数的顺序一致。<br>
简单修改以上代码：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span>
    f <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> number <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment">#print(f"Task {name}: Compute factorial({i})...")</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        f <span class="token operator">*=</span> i

    <span class="token comment">#print(f"Task {name}: factorial({number}) = {f}")</span>
    <span class="token keyword">return</span> number

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Schedule three calls *concurrently*:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>
        factorial<span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        factorial<span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        factorial<span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># Expected output:</span>
<span class="token comment">#</span>
<span class="token comment">#[2, 3, 4]#await asyncio.gather()的返回值是一个列表，</span>
<span class="token comment">#分别对应factorial("A", 2),factorial("B", 3),factorial("C", 4)的执行结果。</span>

</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>如果<code>return_execptions</code>参数为<code>False</code>（默认值即为<code>False</code>），引发的第一个异常会立即传播给等待<code>gather()</code>的任务，即调用<code>await asyncio.gather()</code>对象。序列中其他<code>awaitable</code>对象的执行不会受影响。例如：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio


<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">division</span><span class="token punctuation">(</span>divisor<span class="token punctuation">,</span> dividend<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> ZeroDivisionError
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{dividend}/{divisor}={dividend/divisor}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> dividend<span class="token operator">/</span>divisor

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Schedule three calls *concurrently*:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>
        division<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        division<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        division<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>执行结果：</p>
</div><div class="cl-preview-section"><pre><code>2/1=2.0
2/2=1.0
Traceback (most recent call last):
  File "test.py", line 19, in &lt;module&gt;
    asyncio.run(main())
  File "c:\Program Files\Python37\lib\asyncio\runners.py", line 43, in run
    return loop.run_until_complete(main)
  File "c:\Program Files\Python37\lib\asyncio\base_events.py", line 573, in run_until_complete
    return future.result()
  File "test.py", line 16, in main
    division(2, 2),
  File "test.py", line 6, in division
    raise ZeroDivisionError
ZeroDivisionError
</code></pre>
</div><div class="cl-preview-section"><p>如果<code>return_exceptions</code>参数为<code>True</code>，异常会和正常结果一样，被聚合到结果列表中返回。<br>
对以上代码稍作修改，将<code>return_exceptions</code>设为<code>True</code>：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio


<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">division</span><span class="token punctuation">(</span>divisor<span class="token punctuation">,</span> dividend<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> ZeroDivisionError
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{dividend}/{divisor}={dividend/divisor}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> dividend<span class="token operator">/</span>divisor

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Schedule three calls *concurrently*:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>
        division<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        division<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        division<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        return_exceptions<span class="token operator">=</span><span class="token boolean">True</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>执行结果如下：</p>
</div><div class="cl-preview-section"><pre><code>2/1=2.0
2/2=1.0
[ZeroDivisionError(), 2.0, 1.0]#错误不会向上传播，而是作为结果返回
</code></pre>
</div><div class="cl-preview-section"><p>如果<code>gather()</code>被取消，则提交的所有<code>awaitable</code>对象（尚未执行完成的）都会被取消。例如：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">division</span><span class="token punctuation">(</span>divisor<span class="token punctuation">,</span> dividend<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> ZeroDivisionError
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>divisor<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{dividend}/{divisor}={dividend/divisor}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> dividend<span class="token operator">/</span>divisor

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Schedule three calls *concurrently*:</span>
    t <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>
        division<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        division<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        division<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        return_exceptions<span class="token operator">=</span><span class="token boolean">True</span>
    <span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    t<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> t

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>执行结果：</p>
</div><div class="cl-preview-section"><pre><code>5/1=5.0 #除已执行的之外，其他的任务全部被取消
Traceback (most recent call last):
  File "test.py", line 23, in &lt;module&gt;
    asyncio.run(main())
  File "c:\Program Files\Python37\lib\asyncio\runners.py", line 43, in run
    return loop.run_until_complete(main)
  File "c:\Program Files\Python37\lib\asyncio\base_events.py", line 573, in run_until_complete
    return future.result()
concurrent.futures._base.CancelledError
#在return_exceptions=True的情况下，异常依然向上传播。
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>如果<code>aws</code>中某些<code>Task</code>或<code>Future</code>被取消，<code>gather()</code>调用不会被取消，被取消的<code>Task</code>或<code>Future</code>会以引发<code>CancelledError</code>的方式被处理。这样可以避免个别<code>awaitable</code>对象的取消操作影响其他<code>awaitable</code>对象的执行。<br>
例如：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">division</span><span class="token punctuation">(</span>divisor<span class="token punctuation">,</span> dividend<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> ZeroDivisionError
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>divisor<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{dividend}/{divisor}={dividend/divisor}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> dividend<span class="token operator">/</span>divisor

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Schedule three calls *concurrently*:</span>
    task1 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>division<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    task2 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>division<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    task3 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>division<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    t <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>
        task1<span class="token punctuation">,</span>
        task2<span class="token punctuation">,</span>
        task3<span class="token punctuation">,</span>
        return_exceptions<span class="token operator">=</span><span class="token boolean">True</span>
    <span class="token punctuation">)</span>
    task1<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token keyword">await</span> t<span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><span id="code-preview" style="display: none;">预览</span></pre>
</div><div class="cl-preview-section"><p>预期执行结果如下：</p>
</div><div class="cl-preview-section"><pre><code>5/1=5.0
6/3=2.0
[CancelledError(), 5.0, 2.0] # 仅task1被取消，其他任务不受影响。
</code></pre>
</div><div class="cl-preview-section"><h3 id="避免取消">避免取消</h3>
<pre><code>awaitable asyncio.shield(aw, * , loop=None)
</code></pre>
</div><div class="cl-preview-section"><p>防止<code>awaitable</code>对象被<a href="https://docs.python.org/3/library/asyncio-task.html#asyncio.Task.cancel">取消(cancelled)</a>执行。<br>
如果<code>aw</code>参数是一个<code>协程(coroutines)</code>,该对象会被自动封装为<code>Task</code>对象进行处理。<br>
通常，代码：</p>
<pre><code>#code 1
res = await shield(something())
</code></pre>
</div><div class="cl-preview-section"><p>同代码：</p>
<pre><code>#code 2
res = await something()
</code></pre>
</div><div class="cl-preview-section"><p>是等价的。<br>
特殊情况是，如果包含以上代码的<code>协程</code>被 <strong>取消</strong>，<code>code 1</code>与<code>code 2</code>的执行效果就完全不同了：</p>
</div><div class="cl-preview-section"><ul>
<li><code>code 1</code>中，运行于<code>something()</code>中的任务 <strong>不会被取消</strong>。</li>
<li><code>code 2</code>中，运行于<code>something()</code>中的任务 <strong>会被取消</strong>。</li>
</ul>
</div><div class="cl-preview-section"><p>在<code>code 1</code>中，从<code>something()</code>的视角看，取消操作并没有发生。然而，事实上它的调用者确实被取消了，所以<code>await shield(something())</code>仍然会引发一个<code>CancelledError</code>异常。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> time

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">division</span><span class="token punctuation">(</span>divisor<span class="token punctuation">,</span> dividend<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> ZeroDivisionError
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>divisor<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{time.strftime('%X')}:{dividend}/{divisor}={dividend/divisor}"</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> dividend<span class="token operator">/</span>divisor

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Schedule three calls *concurrently*:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Start time:{time.strftime('%X')}"</span><span class="token punctuation">)</span>
    task1 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>shield<span class="token punctuation">(</span>division<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    task2 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>division<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    task3 <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>division<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    res <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span>task1<span class="token punctuation">,</span> task2<span class="token punctuation">,</span> task3<span class="token punctuation">,</span> return_exceptions<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>

    task1<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>
    task2<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token keyword">await</span> res<span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>执行结果：</p>
</div><div class="cl-preview-section"><pre><code>Start time:10:38:48
10:38:49:2/1=2.0
10:38:51:6/3=2.0
[CancelledError(), CancelledError(), 2.0]
#task1虽然被取消，但是division(1,2)依然正常执行了。
#task2被取消后，division(1,5)没有执行
#虽然task1内的协程被执行，但返回值依然为CancelledError
</code></pre>
</div><div class="cl-preview-section"><p>如果<code>something()</code>以其他的方式被取消，比如从自身内部取消，那么<code>shield()</code>也会被取消。<br>
如果希望完全忽略<code>取消操作</code>（不推荐这么做），则可以将<code>shield()</code>与<code>try/except</code>结合起来使用：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token keyword">await</span> shield<span class="token punctuation">(</span>something<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> CancelledError<span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token boolean">None</span>
</code></pre>
</div><div class="cl-preview-section"><h2 id="超时（timeouts）">超时（Timeouts）</h2>
</div><div class="cl-preview-section"><pre><code>coroutine asyncio.wait_for(aw,timeout,*,loop=None)
</code></pre>
</div><div class="cl-preview-section"><p>在<code>timeout</code>时间之内，等待<code>aw</code>参数指定的<code>awaitable</code>对象执行完毕。<br>
如果<code>aw</code>是一个协程，则会被自动作为<code>Task</code>处理。<br>
<code>timeout</code>可以是<code>None</code>也可以是一个<code>float</code>或<code>int</code>类型的数字，表示需要等待的秒数。如果<code>timeout</code>是<code>None</code>，则永不超时，一直阻塞到<code>aw</code>执行完毕。<br>
如果达到<code>timeout</code>时间，将会取消待执行的任务，引发<code>asyncio.TimeoutError</code>.<br>
如果想避免任务被取消，可以将其封装在<code>shield()</code>中。<br>
程序会等待到任务确实被取消掉，所以等待的总时间会比<code>timeout</code>略大。<br>
如果<code>await_for()</code>被取消，<code>aw</code>也会被取消。<br>
<code>loop</code>参数将在Python3.10中删除，所以不推荐使用。<br>
示例：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">eternity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Sleep for one hour</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3600</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'yay!'</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Wait for at most 1 second</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>wait_for<span class="token punctuation">(</span>eternity<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">1.0</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>TimeoutError<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'timeout!'</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># Expected output:</span>
<span class="token comment">#</span>
<span class="token comment">#     timeout!</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>Python3.7新特性</em>：当<code>aw</code>因为超时被取消，<code>wait_for()</code>等到<code>aw</code>确实被取消之后返回异常。在<em>以前的版本中</em>，<code>wait_for</code>会立即返回异常。</p>
</div><div class="cl-preview-section"><h2 id="等待原语（waiting-primitives）">等待原语（Waiting Primitives）</h2>
</div><div class="cl-preview-section"><h3 id="wait">wait()</h3>
</div><div class="cl-preview-section"><pre><code>coroutine asyncio.wait(aws,*,loop=None,timeout=None,return_when=ALL_COMPLETED)
</code></pre>
</div><div class="cl-preview-section"><p>并发执行<code>aws</code>中的<code>awaitable</code>对象，一直阻塞到<code>return_when</code>指定的情况出现。<br>
如果<code>aws</code>中的某些对象是<code>协程（coroutine）</code>，则自动转换为<code>Task</code>对象进行处理。直接将<code>coroutine</code>对象传递给<code>wait()</code>会导致令人迷惑的执行结果，所以不建议这么做。<br>
返回值是两个<code>Task/Future</code>集合:(<code>done,pending</code>)。<br>
用法示例：</p>
</div><div class="cl-preview-section"><pre><code>done,pending = await asyncio.wait(aws)
</code></pre>
</div><div class="cl-preview-section"><p><code>loop</code>参数将在Python3.10中删除，所以不建议使用。<br>
<code>timeout</code>参数可以是一个<code>int</code>或<code>float</code>类型的值，可以控制最大等待时间。<br>
需要注意的是，<code>wait()</code>不会引发<code>asyncio.TimeoutError</code>错误。返回前没有被执行的<code>Future</code>和<code>Task</code>会被简单的放入<code>pending</code>集合。<br>
<code>return_when</code>决定函数返回的时机。它只能被设置为以下常量：</p>
</div><div class="cl-preview-section"><div class="table-wrapper"><table>
<thead>
<tr>
<th>Constant</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIRST_COMPLETED</td>
<td>The function will return when any future finishes or is cancelled.</td>
</tr>
<tr>
<td>FIRST_EXCEPTION</td>
<td>The function will return when any future finishes by raising an exception. If no future raises an exception then it is equivalent to ALL_COMPLETED.</td>
</tr>
<tr>
<td>ALL_COMPLETED</td>
<td>The function will return when all futures finish or are cancelled.</td>
</tr>
</tbody>
</table>
</div></div><div class="cl-preview-section"><p>与<code>wait_for()</code>不同，<code>wait()</code>不会再超时的时候取消任务。<br>
<strong>注意：</strong><br>
因为<code>wait()</code>会自动将<code>协程</code>转换为<code>Task对象</code>进行处理，然后返回这些隐式创建的<code>Task</code>到（done,pending）集合，所以以下代码不会如预期的那样执行。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token number">42</span>

coro <span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
done<span class="token punctuation">,</span> pending <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">{</span>coro<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> coro <span class="token keyword">in</span> done<span class="token punctuation">:</span>
    <span class="token comment"># 因为wait()会自动将协程转换为Task对象进行处理，然后返回这些隐式创建的Task到（done,pending）集合，所以这个条件分支永远不会被执行。</span>
</code></pre>
</div><div class="cl-preview-section"><p>上面的代码可以做如下修正：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token number">42</span>

task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
done<span class="token punctuation">,</span> pending <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">{</span>task<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> task <span class="token keyword">in</span> done<span class="token punctuation">:</span>
    <span class="token comment"># 这回可以正常执行了.</span>
</code></pre>
</div><div class="cl-preview-section"><p>所以，正如上文所讲，不建议将<code>coroutine</code>对象直接传递给<code>wait()</code>。</p>
</div><div class="cl-preview-section"><h3 id="as_completed">as_completed()</h3>
</div><div class="cl-preview-section"><pre><code>asyncio.as_completed(aws,*,loop=None,timeout=None)
</code></pre>
</div><div class="cl-preview-section"><p>并发执行<code>aws</code>中的<code>awaitable</code>对象。返回一个<code>Future</code>对象迭代器。每次迭代时返回的<code>Future</code>对象代表待执行的<code>awaitable</code>对象集合里最早出现的结果。<strong>注意</strong>：迭代器返回的顺序与<code>aws</code>列表的顺序无关，只与结果出现的早晚有关。<br>
如果超时之前还有<code>Future</code>对象未完成，则引发<code>asyncio.TimeoutError</code>异常。<br>
用法示例：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">for</span> f <span class="token keyword">in</span> as_completed<span class="token punctuation">(</span>aws<span class="token punctuation">)</span><span class="token punctuation">:</span>
    earliest_result <span class="token operator">=</span> <span class="token keyword">await</span> f
    <span class="token comment"># ...</span>
</code></pre>
</div><div class="cl-preview-section"><p>以下为一个完整的例子：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> time

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">eternity</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"delay for {delay} seconds."</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> delay

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Start at: {time.strftime('%X')}"</span><span class="token punctuation">)</span>
    tasks <span class="token operator">=</span> <span class="token punctuation">[</span>eternity<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> f <span class="token keyword">in</span> asyncio<span class="token punctuation">.</span>as_completed<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> <span class="token keyword">await</span> f
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"End at: {time.strftime('%X')}"</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>执行结果如下：</p>
</div><div class="cl-preview-section"><pre><code>Start at: 17:19:11
delay for 0 seconds.
delay for 1 seconds.
delay for 2 seconds.
delay for 3 seconds.
delay for 4 seconds.
delay for 5 seconds.
delay for 6 seconds.
delay for 7 seconds.
delay for 8 seconds.
delay for 9 seconds.
End at: 17:19:20

</code></pre>
</div><div class="cl-preview-section"><h2 id="从其他线程调度执行（scheduling-from-other-threads）">从其他线程调度执行（Scheduling From Other Threads）</h2>
</div><div class="cl-preview-section"><pre><code>asyncio.run_coroutine_threadsafe(coro,loop)
</code></pre>
</div><div class="cl-preview-section"><p>向<code>loop</code>指定的事件循环提交一个由<code>coro</code>指定协程。线程安全。<br>
返回一个<code>concurrent.futures.Future</code>对象，等待另一个线程返回结果。<br>
这个函数用于从<code>当前线程</code>向<code>运行事件循环的线程</code>提交<code>协程(coroutine)</code>。<br>
例如：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment"># Create a coroutine</span>
coro <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> result<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>

<span class="token comment"># Submit the coroutine to a given loop</span>
future <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>run_coroutine_threadsafe<span class="token punctuation">(</span>coro<span class="token punctuation">,</span> loop<span class="token punctuation">)</span>

<span class="token comment"># Wait for the result with an optional timeout argument</span>
<span class="token keyword">assert</span> future<span class="token punctuation">.</span>result<span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span>
</code></pre>
</div><div class="cl-preview-section"><p>如果<code>协程</code>出现异常，返回的<code>Future</code>会收到通知。返回的<code>Future</code>也可以被用作取消事件循环中的任务：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> future<span class="token punctuation">.</span>result<span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>
<span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>TimeoutError<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The coroutine took too long, cancelling the task...'</span><span class="token punctuation">)</span>
    future<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> Exception <span class="token keyword">as</span> exc<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'The coroutine raised an exception: {exc!r}'</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'The coroutine returned: {result!r}'</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>可以参考<a href="https://docs.python.org/3/library/asyncio-dev.html#asyncio-multithreading">并发与多线程</a>章节。<br>
与其他asyncio函数不同，该函数需要 <strong>显式</strong> 传递<code>loop</code>参数。<br>
<strong>新增于Python 3.5.1</strong></p>
</div><div class="cl-preview-section"><h2 id="自查（introspection）">自查（Introspection）</h2>
</div><div class="cl-preview-section"><h3 id="current_task">current_task()</h3>
</div><div class="cl-preview-section"><pre><code>asyncio.current_task(loop=None)
</code></pre>
</div><div class="cl-preview-section"><p>返回事件循环中正在运行的<code>Task</code>实例，如果没有<code>Task</code>在执行，则返回<code>None</code>。<br>
如果<code>loop</code>为<code>None</code>,则使用<code>get_running_loop()</code>获取当前事件循环。<br>
<strong>新增于Python3.7</strong></p>
</div><div class="cl-preview-section"><h3 id="all_tasks">all_tasks()</h3>
</div><div class="cl-preview-section"><pre><code>asyncio.all_tasks(loop=None)
</code></pre>
</div><div class="cl-preview-section"><p>返回事件循环中尚未运行结束的<code>Task</code>对象集合。<br>
如果<code>loop</code>为<code>None</code>，则，使用<code>get_running_loop()</code>获取当前事件循环。<br>
<strong>新增于Python3.7</strong></p>
</div><div class="cl-preview-section"><h2 id="task对象">Task对象</h2>
</div><div class="cl-preview-section"><pre><code>class asyncio.Task(coro,*,loop=None)
</code></pre>
</div><div class="cl-preview-section"><p>类似与<code>Future</code>对象，用于执行Python协程。非线程安全。<br>
<code>Tasks</code>用于在<code>事件循环</code>中执行<code>协程</code>。如果<code>协程</code>等待一个<code>Future</code>，那么<code>Task</code>会暂停<code>协程</code>的执行，直到<code>Future</code>执行完成。当<code>Future</code>完成时，<code>协程</code>的执行会恢复。<br>
事件循环的 <em>协作调度</em> 模式：一个事件循环同一时间只执行一个<code>Task</code>。当这个<code>Task</code>等待某个<code>Future</code>返回时，事件循环执行其他的<code>Task</code>、<code>回调</code>或<code>IO操作</code>。</p>
</div><div class="cl-preview-section"><p>可以通过高层函数<code>asyncio.create_task()</code>创建<code>Task</code>，或者通过底层函数<code>loop.create_task()</code>和<code>ensure_future()</code>创建<code>Task</code>。但是不建议直接实例化<code>Task</code>对象。</p>
</div><div class="cl-preview-section"><p>如果想要取消一个<code>Task</code>的执行，可以使用<code>cancel()</code>方法。调用<code>cancel()</code>会引起<code>Task</code>对象向被封装的<code>协程</code>抛出<code>CancelledError</code>异常。当取消行为发生时，如果<code>协程</code>正在等待某个<code>Future</code>对象执行，该<code>Future</code>对象将被取消。</p>
</div><div class="cl-preview-section"><p><code>cancelled()</code>方法用于检查某个<code>Task</code>是否已被取消。如果<code>Task</code>封装的<code>协程</code>没有阻止<code>CancelledError</code>异常，且<code>Task</code>确实被取消了，则该方法返回<code>True</code>。</p>
</div><div class="cl-preview-section"><p><code>asyncio.Task</code>继承了<code>Future</code>类中除<code>Future.set_result()</code>和<code>Future.set_exception()</code>以外的所有方法。</p>
</div><div class="cl-preview-section"><p><code>Task</code>对象支持<code>contextvars</code>模块：当一个<code>Task</code>被创建的时候，它会复制当前的上下文，然后在复制的上下文副本中执行协程。</p>
</div><div class="cl-preview-section"><p><strong>Python3.7中的变更</strong>：添加了对<code>contextvars</code>模块的支持。</p>
</div><div class="cl-preview-section"><h3 id="cancel">cancel()</h3>
</div><div class="cl-preview-section"><p>申请取消任务。<br>
将在下一个事件循环周期中将<code>CancelledError</code>异常抛给封装在<code>Task</code>中的协程。<br>
收到<code>CancelledError</code>异常后，<code>协程</code>有机会处理异常，甚至以<code>try ...except CancelledError ...finally</code>来拒绝请求。因此，与<code>Future.cancel()</code>不同，<code>Task.cancel()</code>不能保证<code>Task</code>一定被取消掉。当然，拒绝取消请求这种操作并不常见，而且很不提倡。</p>
</div><div class="cl-preview-section"><p>以下例子可以说明协程如何拦截取消请求：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">cancel_me</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cancel_me(): before sleep'</span><span class="token punctuation">)</span>

    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token comment"># Wait for 1 hour</span>
        <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3600</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>CancelledError<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cancel_me(): cancel sleep'</span><span class="token punctuation">)</span>
        <span class="token keyword">raise</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cancel_me(): after sleep'</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># Create a "cancel_me" Task</span>
    task <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>cancel_me<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># Wait for 1 second</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

    task<span class="token punctuation">.</span>cancel<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> task
    <span class="token keyword">except</span> asyncio<span class="token punctuation">.</span>CancelledError<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"main(): cancel_me is cancelled now"</span><span class="token punctuation">)</span>

asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># Expected output:</span>
<span class="token comment">#</span>
<span class="token comment">#     cancel_me(): before sleep</span>
<span class="token comment">#     cancel_me(): cancel sleep</span>
<span class="token comment">#     cancel_me(): after sleep</span>
<span class="token comment">#     main(): cancel_me is cancelled now</span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="cancelled">cancelled()</h3>
</div><div class="cl-preview-section"><p>如果<code>Task</code>已经被取消，则返回<code>True</code>。<br>
当取消请求通过<code>cancel()</code>被提交，且<code>Task</code>封装的<code>协程</code>传播了抛给它的<code>CancelledError</code>异常，则此<code>Task</code>被取消。</p>
</div><div class="cl-preview-section"><h3 id="done">done()</h3>
</div><div class="cl-preview-section"><p>如果<code>Task</code>已完成，则返回<code>True</code>。<br>
<code>Task</code>完成有三种情况：</p>
</div><div class="cl-preview-section"><ul>
<li>封装的协程已返回</li>
<li>封装的协程已抛出异常</li>
<li><code>Task</code>被取消</li>
</ul>
</div><div class="cl-preview-section"><h3 id="result">result()</h3>
</div><div class="cl-preview-section"><p>返回<code>Task</code>的执行结果。<br>
如果<code>Task</code>已经完成，则返回<code>Task</code>封装的协程的执行结果（如果<code>Task</code>封装的协程引发异常，则重新引发该异常）。<br>
如果<code>Task</code>已经取消，则该方法引发<code>CancelledError</code>异常。<br>
如果<code>Task</code>的结果还不可用，该方法引发<code>InvalidStateError</code>异常。</p>
</div><div class="cl-preview-section"><h3 id="exception">exception()</h3>
</div><div class="cl-preview-section"><p>返回<code>Task</code>的异常。<br>
如果封装的协程引发了异常，则返回此异常。如果封装的协程执行正常，则返回<code>None</code>。<br>
如果<code>Task</code>已被取消，则引发<code>CancelledError</code>异常。<br>
如果<code>Task</code>尚未完成，则引发<code>InvalidStateError</code>异常。</p>
</div><div class="cl-preview-section"><h3 id="add_done_callback">add_done_callback()</h3>
</div><div class="cl-preview-section"><p>添加一个回调函数，在<code>Task</code>完成后执行。<br>
这个方法只应用在基于回调的底层编程中。<br>
具体细节可以参考<a href="https://docs.python.org/3/library/asyncio-future.html#asyncio.Future.remove_done_callback"><code>Future.remove_done_callback()</code></a></p>
</div><div class="cl-preview-section"><h3 id="get_stack-limitnone">get_stack(* ,limit=None)</h3>
</div><div class="cl-preview-section"><p>返回此<code>Task</code>的堆栈帧列表。</p>
</div><div class="cl-preview-section"><ul>
<li>如果封装的协程未完成，此方法返回它暂停位置的堆栈。</li>
<li>如果封装的协程已经完成或已被取消，此方法返回一个空的列表。</li>
<li>如果封装的协程因异常而结束，此方法返回异常回溯列表。</li>
</ul>
</div><div class="cl-preview-section"><p>帧的顺序总是 <strong>由旧到新</strong>。<br>
暂停中的协程只返回一个堆栈帧。<br>
可选参数<code>limit</code>用于限定返回帧的最大数目。默认情况下，所有有效的帧都会返回。<br>
在返回堆栈和返回异常回溯时，列表的顺序会有所不同：</p>
</div><div class="cl-preview-section"><ul>
<li>最新的堆栈帧会被返回</li>
<li>最老的回溯帧会被返回（这和异常回溯模块的机制有关）</li>
</ul>
</div><div class="cl-preview-section"><h3 id="print_stack-limitnonefilenone">print_stack(* ,limit=None,file=None)</h3>
</div><div class="cl-preview-section"><p>打印<code>Task</code>的栈帧或异常回溯。<br>
此方法用于输出由<code>get_stack()</code>取回的帧列表，输出形式类似于<code>回溯(traceback)模块</code><br>
<code>limit</code>参数会直接传递给<code>get_stack()</code>。<br>
<code>file</code>参数指定输出的I/O流，默认为<code>sys.stderr</code>。</p>
</div><div class="cl-preview-section"><h3 id="classmethod-all_tasksloopnone">classmethod all_tasks(loop=None)</h3>
</div><div class="cl-preview-section"><p>返回一个事件循环上所有任务的集合。<br>
默认情况下，当前事件循环上所有的任务都会被返回。如果<code>loop</code>参数为’None’，则通过<code>get_event_loop()</code>方法获取当前事件循环。</p>
</div><div class="cl-preview-section"><p>此方法将在Python3.9中被移除，所以不建议使用。可以使用<code>asyncio.all_tasks()</code>代替。</p>
</div><div class="cl-preview-section"><h3 id="calssmethod-current_taskloopnone">calssmethod current_task(loop=None)</h3>
</div><div class="cl-preview-section"><p>返回当前正在运行的<code>Task</code>或<code>None</code>。<br>
如果<code>loop</code>参数为’None’，则通过<code>get_event_loop()</code>方法获取当前事件循环。<br>
此方法将在Python3.9中被移除，所以不建议使用。可以使用<code>asyncio.current_task()</code>代替。</p>
</div><div class="cl-preview-section"><h2 id="基于生成器的协程（generator-based-coroutines）">基于生成器的协程（Generator-based Coroutines）</h2>
</div><div class="cl-preview-section"><p><strong>提示</strong>：对基于生成器的协程的支持将在Python3.10中移除，不建议使用。<br>
基于生成器的协程是早期的异步实现方式，出现在<code>async/await</code>语法之前，使用<code>yield from</code>表达式等待<code>Future</code>或其他协程。<br>
基于生成器的协程应该用<code>@asyncio.coroutine</code>来修饰，尽管这不是强制的。</p>
</div><div class="cl-preview-section"><h3 id="asyncio.coroutine">@asyncio.coroutine</h3>
</div><div class="cl-preview-section"><p>基于生成器的协程的修饰器。<br>
这个修饰器能使传统的<code>基于生成器的协程</code>与<code>async/await</code>语法兼容：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">@asyncio<span class="token punctuation">.</span>coroutine
<span class="token keyword">def</span> <span class="token function">old_style_coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">yield</span> <span class="token keyword">from</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">await</span> old_style_coroutine<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>此修饰器将在Python3.10中被移除，所以不建议再使用。<br>
此修饰器不能用于<code>async def</code>的协程中。</p>
</div><div class="cl-preview-section"><h3 id="asyncio.iscoroutineobj">asyncio.iscoroutine(obj)</h3>
</div><div class="cl-preview-section"><p>如果<code>obj</code>对象是一个<code>coroutine</code>对象，则返回<code>True</code>。<br>
此方法与<code>inspect.iscoroutine()</code>不同，因为它对基于生成器的协程也返回<code>True</code>。</p>
</div><div class="cl-preview-section"><h3 id="asyncio.iscoroutinefunctionfunc">asyncio.iscoroutinefunction(func)</h3>
</div><div class="cl-preview-section"><p>如果<code>func</code>是一个<code>coroutine</code>方法，则返回<code>True</code>。<br>
此方法<code>inspect.iscoroutinefunction()</code>不同，因为它对用<code>@coroutine</code>修饰的基于生成器的协程也返回<code>True</code>。</p>
</div></div>