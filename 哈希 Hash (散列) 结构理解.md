[出处](https://www.jianshu.com/p/de33dc676a3f)

# Hash 表结构
 
Hash表采用一个映射函数 f :<br>
==key —> address==<br>
将 key 关键字映射到该记录在表中的存储位置，<br>

从而在想要查找该记录时，可以直接根据==key关键字和**值的地址**的映射关系==得到该记录在表中的存储位置，<br>
通常情况下，这种 **映射关系称作为Hash函数**，<br>
而通过Hash函数和 key 关键字计算出来的存储位置(注意这里的存储位置只是表中的存储位置，并不是实际的物理地址)称作为 **Hash地址**。<br>

比如上述例子中，假如联系人信息采用Hash表存储，<br>
则当想要找到“李四”的信息时，直接根据“李四”和Hash函数计算出Hash地址即可

# Hash 表设计
Hash函数设计的好坏直接影响到对Hash表的操作效率。

## 错误例子
下面举例说明：
假如对上述的联系人信息进行存储时，
```
采用的 Hash 函数为：姓名的每个字的拼音开头大写字母的ASCII码之和:
    address(张三) = ASCII(Z)+ASCII(S) = 90+83 = 173;
    address(李四) = ASCII(L)+ASCII(S) = 76+83 = 159;
    address(王五) = ASCII(W)+ASCII(W) = 87+87 = 174;
    address(张帅) = ASCII(Z)+ASCII(S) = 90+83 = 173;
```
假如只有这4个联系人信息需要进行存储，这个Hash函数设计的很糟糕
- 它浪费了大量的存储空间。因为假如采用`char`型数组存储联系人信息的话，每个人的信息需要12个字节来存储
- 冲突。address(张三)和address(张帅)具有相同的地址,只需要存储4条记录就发生了冲突


# 一、几种 Hash 函数构造哈希值

## 1. 直接定址法 (线性函数)

取 key 关键字或者关键字的某个 **==线性函数==** 为 Hash 地址，<br>即 **`address(key)=a*key+b`**;<br>

如知道学生的学号从2000开始，最大为4000，<br>则可以将 **`address(key) = key-2000`** 作为Hash地址。


## 2. 平方取中法

- 对 key 关键字进行 **==平方运算==**，
- 然后 **==取结果的中间几位==** 作为 Hash 地址。<br>

 假如有以下 key 关键字序列 {421，423，436}，<br>平方之后的结果为 {177241，178929，190096}，<br>那么可以**取中间的两位数** **{72，89，00}** 作为Hash地址。

## 3. 折叠法

- 将 key 关键字 **==拆分==** 成几部分，
- 然后将这几部分以 **==特定的方式组合==** 在一起， 进行转化形成Hash地址。<br>

假如知道图书的 ISBN 号为 8903-241-23，<br>可以将 **`address(key) = 89 + 03 + 24 + 12 + 3`** 作为Hash地址。

## 4. 除留取余法
如果知道 Hash 表的最大长度为m，可以取 **==不大于m的最大质数 p==** ，<br>然后对 key 关键字进行 **==取余==** 运算。
**`address(key) = key % p`** <br>

在这里p的选取非常关键，p选择的好的话，能够最大程度地减少冲突，<u>p一般取不大于m的最大质数</u> 。


<br>


# 二、Hash 表大小的确定





<br>
<br>





# 三、解决冲突
**冲突** : 
通过 Hash 函数得到的地址集合中 有两个以上是相同的，
那么通过 key 查找是就会造成 不同的值查找到的同一个地址。
但一个地址有两个不一样的值，即产生冲突。


虽然能够采用一些办法去减少冲突，但是冲突是无法完全避免的。因此需要根据实际情况选取解决冲突的办法。

## 1. 开放定址法（探测法

即当一个 key 关键字和另一个 key 关键字发生冲突时，
使用某种探测技术在Hash表中形成一个探测序列，
然后沿着这个探测序列继续依次查找下去，
**==当碰到一个空的单元时，则插入其中==**。

比较常用的探测方法有 <u> **线性探测法**</u>，
比如有一组 key 关键字 
`{12，13，25，23，38，34，6，84，91}` ，
Hash 表长为14，Hash 函数为 **`address(key)= key % 11`** ，
当插入`12，13，25`时可以直接插入，
而当插入`23`时，地址 1 被`12`占用了，
因此沿着地址1依次往下探测 (探测步长可以根据情况而定)，
直到探测到地址 4，发现为空，则将`23`插入其中。


## 2. 链地址法

采用 **==数组和链表相结合==** 的办法，
将 Hash 地址相同的记录存储在一张线性表中，而每张表的表头的序号即为计算得到的 Hash 地址

dino 理解：**假如有两个以上的 key 通过 哈希函数得到同一个地址，那就在那个地址上延伸线性结构，让那个地址能够存储两个以上元素的地址**

![链地址法](https://upload-images.jianshu.io/upload_images/6946981-697dd755189f9d65.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/579/format/webp)

![test](https://github.com/yesdino/img_upload/blob/master/imooc_study/hash/ResolveConflict_LinkMethod.png?raw=true)











<br><br><br><br><br><br>

---
这篇文章还有很多值得写的地方 有空可以继续学下去






<br><br><br>
作者：海天一树X
链接：https://www.jianshu.com/p/de33dc676a3f
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。