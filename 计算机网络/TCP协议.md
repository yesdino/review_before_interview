[toc]


---



# 1、TCP 协议


[非原创 出处](https://www.cnblogs.com/jking10/p/5525519.html)

TCP(Transmission Control Protocol) 传输控制协议。
TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用==三次==握手确认建立一个连接。

## 位码 (tcp标志位)
即tcp标志位，有6种标示:
- **==SYN==** (synchronous建立联机) 
- **==ACK==** (acknowledgement 确认) 
- **PSH** (push传送) 
- **==FIN==** (finish结束) 
- **RST** (reset重置) 
- **URG** (urgent紧急)
<br>
- Sequence number(顺序号码) 
- Acknowledge number(确认号码)。

**==手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。==**
TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在" ==**无差别**== "的网络之上。

<br>


## 连接：三次握手
<u>建立起一个TCP连接需要经过“三次握手”</u>
涉及到的包： SYN (连接)， ACK (确认)

**第一次握手**
- ==客户端发送 SYN 包(syn=j)到服务器==，并进入 **SYN_SEND** 状态，
- 等待服务器确认；

**第二次握手**
- ==服务器==收到 SYN 包，
- 必须确认客户的SYN（ack=j+1），同时自己也==发送一个SYN包==（syn=k），即 SYN+ACK 包，
- 此时服务器进入 **SYN_RECV** 状态；

**第三次握手**
- ==客户端==收到服务器的 SYN＋ACK 包，
- ==向服务器发送确认包 ACK (ack=k+1)==，此包发送完毕，
- 客户端和服务器进入 **ESTABLISHED** 状态，完成三次握手。


## 实例
TCP的作用是**流量控制**，主要是**控制数据流的传输**。

下面以浏览网页为例，根据自身理解来解释一下这个过程。（注：第二个ack属于代码段ack位）
pc 浏览服务器网页此过程不包括域名查询，只描述 TCP 与 http 数据流的变化。
pc 与 http 服务器进行三次握手来建立连接。

动画：
https://blog.csdn.net/bntX2jSQfEHy7/article/details/80837422

### 1) 三次握手：建立 TCP 连接

```py
1. PC --> seq=0, ack=0, syn=1, ack=0 --> server  # SYN 建立同步TCP连接请求
2. PC <-- seq=0, ack=1, syn=1, ack=1 <-- server  # SYN+ACK 同步响应 并确定是否连接
3. PC --> seq=1, ack=1, syn=0, ack=1 --> server  # SEQ+ACK 结果确定, 正式连接
```

握手过程中传送的包里不包含数据，**三次握手完毕后，客户端与服务器才正式开始传送数据**。



### 2) 握手成功后开始传输数据
1. pc :  产生 http 数据消息，向服务器发送 get 请求.
2. server : 收到请求并发送 **==TCP 确认==**，然后发送 http 数据信息给客户端的浏览器.
3. pc :  收到服务器的 http 信息，然后发送 TCP 确认信息给服务器.
```py
1.  PC --> 请求data --> server     # 请求数据 data

2.  PC <--   ACK   <-- server     # 响应, 告诉 PC 收到请求了
3.  PC <--   data  <-- server     # 返回数据 data

4.  PC -->   ACK   --> server     # 确定, 告诉 server 收到 data 了
```

理想状态下，<u>TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去</u>。

### 3) 四次挥手：关闭 TCP 连接
<u>断开连接时服务器和客户端均可以主动发起断开TCP连接的请求</u>，断开过程需要经过“四次挥手”。
**FIN**：结束，**ACK**：确认
```py
1.  PC --> FIN + ACK --> server     # 请求关闭 TCP 连接

2.  PC <-- ACK       <-- server     # 响应, 告诉 PC 收到关闭请求了
3.  PC <-- FIN + ACK <-- server     # 关闭 TCP 连接

4.  PC --> ACK       --> server     # 确定, 告诉 server 收到, 整个会话结束
```
## 实例2
```py
# 第一次握手： 192.168.1.116 发送位码 syn 1, 随机产生 seq number=3626544836 的数据包到 192.168.1.123,
# 192.168.1.123 由 SYN=1 知道 192.168.1.116 要求建立联机 ;
IP 192.168.1.116 > 192.168.1.123: S 3626544836:3626544836

# 第二次握手： 192.168.1.123 收到请求后要确认联机信息，向 192.168.1.116 发送 ack number=3626544837,syn=1,ack=1, 随机产生 seq=1739326486 的包 ; 
IP 192.168.1.123 > 192.168.1.116: S 1739326486:1739326486 ack 3626544837

# # 第三次握手： 192.168.1.116 收到后检查 ack number 是否正确，即第一次发送的 seq number+1, 以及位码 ack 是否为 1 ，若正确， 192.168.1.116 会再发送 ack number=1739326487,ack=1 ， 192.168.1.123 收到后确认 seq=seq+1,ack=1 则连接建立成功。
IP 192.168.1.116 > 192.168.1.123: ack 1739326487,ack 1
```